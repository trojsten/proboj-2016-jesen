/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package gui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author siegrift
 */
public class Frame extends javax.swing.JFrame implements Runnable {

    /**
     * Creates new form Frame
     */
    private double SLEEP_TIME = 500;
    private double MIN_SLEEP_TIME = 20;
    private double MAX_SLEEP_TIME = 3000;
    private double SLEEP_UNIT = 1.2;
    public static final Font RESULTS_FONT = new Font("Noto Sans", Font.PLAIN, 20);
    private String NEXT_TURN_LOG = "TAH ";

    public Frame() {
        initAll();
    }

    public Frame(String file) {
        filename = file;
        initAll();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        tabbedPane = new javax.swing.JTabbedPane();
        jScrollPane3 = new javax.swing.JScrollPane();
        resultsTable = new javax.swing.JTable();
        jPanel1 = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Observer");

        tabbedPane.setFont(RESULTS_FONT);

        resultsTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Meno", "Body"
            }
        ));
        resultsTable.setEnabled(false);
        jScrollPane3.setViewportView(resultsTable);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 272, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 236, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(tabbedPane, javax.swing.GroupLayout.DEFAULT_SIZE, 369, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 198, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(tabbedPane, javax.swing.GroupLayout.PREFERRED_SIZE, 198, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    int N, M;
    int numBots;
    boolean paused = false;
    ArrayList<String> botNames;
    ArrayList<Color> botColors;
    ArrayList<JTextArea> botLogs;
    ArrayList<BufferedReader> botLogReaders;
    String filename = null;
    Observer observerPanel;
    int roundNumber=0;
    Scanner in;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTable resultsTable;
    private javax.swing.JTabbedPane tabbedPane;
    // End of variables declaration//GEN-END:variables

    private void bindKeys() {
        tabbedPane.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), "pause");
        tabbedPane.getActionMap().put("pause", pauseObserver());

        tabbedPane.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ADD, InputEvent.CTRL_MASK), "faster");
        tabbedPane.getActionMap().put("faster", fasterObserver());

        tabbedPane.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_SUBTRACT, InputEvent.CTRL_MASK), "slower");
        tabbedPane.getActionMap().put("slower", slowerObserver());

    }

    private Action pauseObserver() {
        Frame instance = this;
        Action a;
        a = new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                synchronized (instance) {
                    paused = !paused;
                    if (paused == false) {
                        instance.notifyAll();
                    }
                }
            }
        };
        return a;
    }

    private Action fasterObserver() {
        Action a = new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                SLEEP_TIME = Math.max(SLEEP_TIME / SLEEP_UNIT, MIN_SLEEP_TIME);
                System.out.println("FAST: " + SLEEP_TIME);
            }
        };
        return a;
    }

    private Action slowerObserver() {
        Action a = new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                SLEEP_TIME = Math.min(SLEEP_TIME * SLEEP_UNIT, MAX_SLEEP_TIME);
                System.out.println(SLEEP_TIME);
            }
        };
        return a;
    }

    private void createBotLogs() {
        botLogs = new ArrayList<>();

        for (int i = 0; i < numBots; i++) {
            JTextArea a = new JTextArea();
            if (filename == null) {
                a.setText("Debugovacie logy sú dostupné iba v lokálnom móde!");
            }
            a.setFont(RESULTS_FONT);
            a.setEditable(false);
            a.setFocusable(false);
            JScrollPane pane = new JScrollPane();
            pane.setViewportView(a);
            botLogs.add(a);
            tabbedPane.add(pane, botNames.get(i));
        }

        //open log files
        if (filename != null) {
            botLogReaders = new ArrayList<>(numBots);
            for (int i = 0; i < numBots; i++) {
                try {
                    BufferedReader read = new BufferedReader(new FileReader(Paths.get(filename, botNames.get(i) + ".log").toFile()));
                    botLogReaders.add(read);
                    //read the frist line
                    if(read.readLine() == null){throw new IOException("Koniec bot logu!");}
                    while (true) {
                        String line = read.readLine();
                        if(line == null){throw new IOException("Koniec bot logu!");}  
                        if (line.startsWith(NEXT_TURN_LOG)) {
                            roundNumber = parseRound(line);
                            break;
                        }
                        botLogs.get(i).setText(botLogs.get(i).getText() + String.format("[ INIT ] %s\n", line));
                    }
                } catch (FileNotFoundException ex) {
                    botLogs.get(i).setText("--NEEXISTUJE LOG!--\n");
                } catch (IOException ex) {
                    botLogs.get(i).setText(botLogs.get(i).getText() + String.format("--KONIEC BOT LOGU!--\n"));
                    botLogReaders.set(i, null);
                }
            }
        }
    }

    private void createTable() {
        resultsTable.setFont(RESULTS_FONT);
        resultsTable.getTableHeader().setFont(RESULTS_FONT);
        resultsTable.setRowHeight(getGraphics().getFontMetrics(RESULTS_FONT).getHeight());

        DefaultTableModel model = (DefaultTableModel) resultsTable.getModel();
        for (int i = 0; i < numBots; i++) {
            model.addRow(new Object[]{botNames.get(i), 0});
        }

        for (int i = 0; i < 2; i++) {
            resultsTable.getColumnModel().getColumn(i).setCellRenderer(new MyTableCellRenderer(botColors));
        }
    }

    private void initObserver() {
        jPanel1.setLayout(new BorderLayout());
        observerPanel = new Observer();
        jPanel1.add(observerPanel);
        if (filename != null) {
            try {
                in = new Scanner(Paths.get(filename, "observation").toFile());
            } catch (FileNotFoundException ex) {
                Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
            }
        } else {
            in = new Scanner(System.in);
        }

        //read header
        numBots = in.nextInt();
        botColors = new ArrayList<>();
        botNames = new ArrayList<>();

        for (int i = 0; i < numBots; i++) {
            botNames.add(in.next());
            float r = in.nextFloat(), g = in.nextFloat(), b = in.nextFloat(), alfa = in.nextFloat();
            botColors.add(new Color(r, g, b));
        }
        N = in.nextInt();
        M = in.nextInt();

        observerPanel.initData(botColors, N, M);
    }

    @Override
    public void run() {
        int data[][][] = new int [N][M][3];
        int heads[][] = new int [numBots][2];
        int live[] = new int [numBots];
        
        while (true) {
            long time = System.currentTimeMillis();
            //read general
            
            int mapN = in.nextInt();
            int mapM = in.nextInt();
            int numB = in.nextInt();
            
            for (int i = 0; i < numBots; i++) {
                heads[i][0] =in.nextInt();
                heads[i][1] = in.nextInt();
                int direciton = in.nextInt();
                live[i] = in.nextInt();
                int score = in.nextInt();

                resultsTable.getModel().setValueAt(score, i, 1);
            }

            //read map
            int numElem = in.nextInt(); //miso prints num of elements in 
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < M; j++) {
                    data[i][j][Observer.WALL_INDEX] = in.nextInt();
                    data[i][j][Observer.AREA_INDEX] = in.nextInt();
                    data[i][j][Observer.SNAKE_INDEX] = in.nextInt();
                }
            }

            //read logs
            for (int i = 0; i < numBots; i++) {
                if(botLogReaders.get(i) == null)continue;
                try {
                    String s = botLogReaders.get(i).readLine();
                    if(s == null){throw new IOException("Koniec bot logu!");}
                    while (s.startsWith(NEXT_TURN_LOG) == false) {
                        botLogs.get(i).setText(botLogs.get(i).getText() + String.format("[Tah %d] %s\n", roundNumber, s));
                        s = botLogReaders.get(i).readLine();
                        if(s == null){throw new IOException("Koniec bot logu!");}
                    }
                    roundNumber = parseRound(s);
                } catch (IOException ex) {
                    botLogReaders.set(i, null);
                    botLogs.get(i).setText(botLogs.get(i).getText() + String.format("--KONIEC BOT LOGU!--\n"));
                    Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
                }
            }

            SwingUtilities.invokeLater(() -> {
                observerPanel.setData(data, heads, live);
                observerPanel.repaint();
            });

            long totTime = (System.currentTimeMillis() - time);
            //System.out.println("TOT time: " + totTime);
            try {
                Thread.sleep((long) Math.max(SLEEP_TIME - totTime, (long) MIN_SLEEP_TIME));
                synchronized (this) {
                    while (paused) {
                        this.wait();
                    }
                }
            } catch (InterruptedException ex) {
                Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
                System.err.println(ex);
            }
        }
    }

    private void startThread() {
        new Thread(this).start();
    }

    public void setFocus() {
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowOpened(WindowEvent e) {
                super.windowOpened(e); //To change body of generated methods, choose Tools | Templates.
                tabbedPane.requestFocus();
            }
        });
    }

    private void initAll() {
        initComponents();
        initObserver();
        createBotLogs();
        createTable();
        bindKeys();

        startThread();
    }

    private int parseRound(String s) {
        return Integer.parseInt(s.split(" ")[1]);
    }

    private static class MyTableCellRenderer extends DefaultTableCellRenderer {

        ArrayList<Color> colors;

        public MyTableCellRenderer(ArrayList<Color> c) {
            colors = c;
        }

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            JLabel l = (JLabel) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
            l.setForeground(colors.get(row));
            return l;
        }
    }
}
